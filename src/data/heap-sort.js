export const heapSortContent = {
  title: "ヒープソート (Heap Sort)",
  overview: `ヒープソートは、ヒープデータ構造を利用した効率的なソートアルゴリズムです。最大ヒープまたは最小ヒープを構築し、ルート要素を順次取り出すことでソートを実現します。時間計算量がO(n log n)で安定しており、インプレースソートが可能な優秀なアルゴリズムです。`,
  
  algorithm: `1. 配列をヒープ構造に変換する（ヒープ化）
2. 最大要素（ルート）を配列の末尾と交換
3. ヒープサイズを1減らす
4. ルートから再度ヒープ化を行う
5. ヒープサイズが1になるまで2-4を繰り返す`,

  codeImplementation: `#include <stdio.h>

// 要素を交換する関数
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// ヒープ化を行う関数
void heapify(int arr[], int n, int i) {
    int largest = i;    // ルートを最大値として初期化
    int left = 2 * i + 1;   // 左の子ノード
    int right = 2 * i + 2;  // 右の子ノード
    
    // 左の子がルートより大きい場合
    if (left < n && arr[left] > arr[largest])
        largest = left;
    
    // 右の子が現在の最大値より大きい場合
    if (right < n && arr[right] > arr[largest])
        largest = right;
    
    // 最大値がルートでない場合
    if (largest != i) {
        swap(&arr[i], &arr[largest]);
        
        // 影響を受けた部分木を再帰的にヒープ化
        heapify(arr, n, largest);
    }
}

// ヒープソートの実装
void heapSort(int arr[], int n) {
    // ヒープを構築（最後の非葉ノードから開始）
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);
    
    // ヒープから要素を一つずつ取り出す
    for (int i = n - 1; i > 0; i--) {
        // 現在のルート（最大値）を末尾に移動
        swap(&arr[0], &arr[i]);
        
        // 縮小されたヒープに対してヒープ化
        heapify(arr, i, 0);
    }
}

// 配列を表示する関数
void printArray(int arr[], int n) {
    for (int i = 0; i < n; i++)
        printf("%d ", arr[i]);
    printf("\\n");
}

// メイン関数
int main() {
    int arr[] = {64, 34, 25, 12, 22, 11, 90};
    int n = sizeof(arr) / sizeof(arr[0]);
    
    printf("ソート前: ");
    printArray(arr, n);
    
    heapSort(arr, n);
    
    printf("ソート後: ");
    printArray(arr, n);
    
    return 0;
}`,

  example: `**実行例:**
初期配列: [64, 34, 25, 12, 22, 11, 90]

ヒープ構築後: [90, 34, 64, 12, 22, 11, 25]
ステップ1: [64, 34, 25, 12, 22, 11] | 90
ステップ2: [34, 22, 25, 12, 11] | 64, 90
ステップ3: [25, 22, 11, 12] | 34, 64, 90
ステップ4: [22, 12, 11] | 25, 34, 64, 90
ステップ5: [12, 11] | 22, 25, 34, 64, 90
ステップ6: [11] | 12, 22, 25, 34, 64, 90

最終結果: [11, 12, 22, 25, 34, 64, 90]`,

  explanation: `ヒープソートは二段階のプロセスで動作します。

第一段階：ヒープ構築
配列を最大ヒープに変換します。最大ヒープでは、親ノードは常に子ノードより大きい値を持ちます。この性質により、ルート要素が配列の最大値となります。

第二段階：ソート処理
最大要素（ルート）を配列の末尾と交換し、ヒープサイズを1減らします。その後、新しいルートから再度ヒープ化を行い、ヒープ性質を維持します。この処理を繰り返すことで、大きい要素から順に正しい位置に配置されます。

ヒープ化（heapify）は、指定されたノードを根とする部分木をヒープ性質を満たすように調整する処理です。子ノードと比較し、必要に応じて交換を行い、再帰的に下位レベルまで調整を続けます。`,

  advantages: [
    "時間計算量がO(n log n)で安定している",
    "インプレースソートが可能で追加メモリが不要",
    "最悪ケースでもO(n log n)の性能を保証",
    "ヒープデータ構造の理解に役立つ"
  ],

  disadvantages: [
    "不安定ソート（同じ値の要素の順序が保持されない）",
    "実装が比較的複雑",
    "キャッシュ効率が良くない",
    "小さなデータセットでは他のアルゴリズムより遅い場合がある"
  ],

  useCases: [
    "大量のデータを効率的にソートしたい場合",
    "メモリ使用量を抑えたいインプレースソート",
    "最悪ケース性能が重要なシステム",
    "優先度付きキューの実装"
  ],

  applications: [
    "オペレーティングシステムのプロセススケジューリング",
    "グラフアルゴリズムでの優先度付きキュー",
    "統計処理での上位k個の要素抽出",
    "リアルタイムシステムでの予測可能な性能"
  ],

  optimizations: [
    "ボトムアップヒープ構築による定数倍の改善",
    "三項ヒープや四項ヒープによる比較回数削減",
    "イントロソートとの組み合わせ",
    "並列化による性能向上"
  ],

  variants: [
    "スムースソート（Smoothsort）",
    "ウィークヒープソート",
    "インクリメンタルヒープソート",
    "外部ヒープソート"
  ]
};

